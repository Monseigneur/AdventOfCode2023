use utilities;

pub fn run() {
    utilities::run_puzzle(2, true, part_1, part_2);
}

fn _part_1_2(data: &str) -> (u32, u32) {
    let mut sum = 0;
    let mut power: u32 = 0;

    for line in data.lines() {
        // line: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green

        let info: Vec<&str> = line.split(':').collect();
        // info: ["Game 1", "3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green"]

        let num: Vec<&str> = info[0].split(' ').collect();

        let num: u32 = num[1].parse().unwrap();

        let mut r = true;
        let mut g = true;
        let mut b = true;

        let mut r_count: u32 = 0;
        let mut g_count: u32 = 0;
        let mut b_count: u32 = 0;

        // println!("line [{line}], num {num}");

        for sub_game in info[1].split(";") {
            // sub_game: "3 blue, 4 red"
            for colors in sub_game.split(",") {
                // colors: "3 blue"
                let pieces: Vec<&str> = colors.trim().split(" ").collect();

                // println!("colors {colors}");

                let count: u32 = pieces[0].parse().unwrap();
                let color: &str = pieces[1];

                match color {
                    "red" => {
                        if count > 12 {
                            r = false;
                        }

                        r_count = r_count.max(count);
                    }
                    "green" => {
                        if count > 13 {
                            g = false;
                        }

                        g_count = g_count.max(count);
                    }
                    "blue" => {
                        if count > 14 {
                            b = false;
                        }

                        b_count = b_count.max(count);
                    }
                    _ => panic!("unknown color"),
                }
            }
        }

        if r && g && b {
            sum += num;
        }

        power += r_count * g_count * b_count;
    }

    // println!("power {power}");

    (sum, power)
}

fn part_1(data: &str) -> u32 {
    calc_score(data, true)
}

fn calc_score(data: &str, as_sum: bool) -> u32 {
    let mut score: u32 = 0;

    for line in data.lines() {
        // line: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green

        let info: Vec<&str> = line.split(':').collect();
        // info: ["Game 1", "3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green"]

        let num: Vec<&str> = info[0].split(' ').collect();

        let num: u32 = num[1].parse().unwrap();

        let mut valid = true;

        let mut r_count: u32 = 0;
        let mut g_count: u32 = 0;
        let mut b_count: u32 = 0;

        // println!("line [{line}], num {num}");

        for sub_game in info[1].split(";") {
            // sub_game: "3 blue, 4 red"
            for colors in sub_game.split(",") {
                // colors: "3 blue"
                let pieces: Vec<&str> = colors.trim().split(" ").collect();

                // println!("colors {colors}");

                let count: u32 = pieces[0].parse().unwrap();
                let color: &str = pieces[1];

                match color {
                    "red" => {
                        valid = valid && count <= 12;
                        r_count = r_count.max(count);
                    }
                    "green" => {
                        valid = valid && count <= 13;
                        g_count = g_count.max(count);
                    }
                    "blue" => {
                        valid = valid && count <= 14;
                        b_count = b_count.max(count);
                    }
                    _ => panic!("unknown color"),
                }
            }
        }

        if valid && as_sum {
            score += num;
        }

        if !as_sum {
            score += r_count * g_count * b_count;
        }
    }

    // println!("power {power}");

    score
}

fn part_2(data: &str) -> u32 {
    calc_score(data, false)
}

// Was bored and tried to do another year.
// fn run_day1_2015() {
//     let path = "((((()(()(((((((()))(((()((((()())(())()(((()((((((()((()(()(((()(()((())))()((()()())))))))))()((((((())((()))(((((()(((((((((()()))((()(())()((())((()(()))((()))()))()(((((()(((()()))()())((()((((())()())()((((())()(()(()(((()(())(()(())(((((((())()()(((())(()(()(()(())))(()((((())((()))(((()(()()(((((()()(()(((()(((((())()))()((()(()))()((()((((())((((())(()(((())()()(()()()()()(())((((())((())(()()))()((((())))((((()())()((((())((()())((())(())(((((()((((()(((()((((())(()(((()()))()))((((((()((())()())))(((()(()))(()()(()(((()(()))((()()()())((()()()(((())())()())())())((()))(()(()))(((((()(()(())((()(())(())()((((()())()))((((())(())((())())((((()(((())(())((()()((((()((((((()(())()()(()(()()((((()))(())()())()))(())))(())))())()()(())(()))()((()(()(())()()))(()())))))(()))(()()))(())(((((()(()(()()((())()())))))((())())((())(()(())((()))(())(((()((((((((()()()(()))()()(((()))()((()()(())(())())()(()(())))(((((()(())(())(()))))())()))(()))()(()(((((((()((((())))())())())())()((((((((((((((()()((((((()()()())())()())())())(())(())))())((()())((()(()))))))()))))))))))))))))())((())((())()()))))))(((()((()(()()))((())(()()))()()())))(())))))))(()(((())))())()())))()()(())()))()(()))())((()()))))(()))))()))(()()(())))))))()(((()))))()(()))(())())))))()))((()))((()))())(())))))))))((((())()))()))()))())(())()()(())))())))(()())()))((()()(())))(())((((((()(())((()(((()(()()(())))()))))))()))()(()((()))()(()))(()(((())((((())())(())(()))))))))())))))))())())))))())))))()()(((())()(()))))))))())))))(())()()()))()))()))(()(())()()())())))))))())()(()(()))))()()()))))())(()))))()()))))()())))))(((())()()))(()))))))))))()()))))()()()))))(()())())()()())()(()))))()(()))(())))))))(((((())(())())()()))()()))(())))))()(()))))(())(()()))()())()))()))()))()))))())()()))())())))(()))(()))))))())()(((())()))))))))()))()())))())))())))()))))))))))()()))(()()))))))(())()(()))))())(()))))(()))))(()())))))())())()()))))())()))))))))(()))))()))))))()(()())))))))()))())))())))())))())))))))())(()()))))))(()())())))()())()))))))))))))))())))()(())))()))())()()(())(()()))(())))())()())(()(()(()))))())))))))))))())(()))()))()))))(())()())()())))))))))))()()))))))))))))())())))))(()())))))))))))())(())))()))))))))())())(()))()))(())))()))()()(())()))))))()((((())()))())())))))()))()))))((()())()))))())))(())))))))))))))))))()))))()()())()))()()))))())()))((()())))())))(()))(()())))))))()))()))))(())))))))(())))))())()()(()))())()))()()))))())()()))))())()))())))))))(()))))()())()))))))))(()))())))(()))()))))(())()))())())(())())())))))))((((())))))()))()))()())()(())))()))()))()())(()())()()(()())()))))())())))))(()))()))))())(()()(())))))(())()()((())())))))(())(())))))))())))))))))()(())))))))()())())())()(()))))))))(()))))))))())()()))()(()))))))()))))))())))))))(())))()()(())()())))))(((())))()((())()))())))(()()))())(())())))()(((()())))))()(()()())))()()(()()(()()))())()(()()()))())()()))()())(()))))())))))())))(())()()))))(()))))(())(()))(())))))()()))()))))())()))()()(())())))((()))())()))))))()()))))((()(()))))()()))))))())))))())(()((()())))))))))))()())())))()))(()))))))(()))(())()())))(()))))))))())()()()()))))(()())))))))((())))()))(()))(())(())()())()))))))))(())))())))(()))()()))(()()))(()))())))()(())))())((()((()(())))((())))()))))((((())())()())))(())))()))))))())(()()((())))())()(()())))))(()())()))())))))))((())())))))))(()(()))())()()(()()(((()(((()())))))()))))))()(())(()()((()()(())()()))())()())()))()())())())))))))(((())))))))()()))))))(((())()))(()()))(()()))))(()(()()((((())()())((()()))))(()(())))))()((()()()())()()((()((()()))(()))(((()()()))(((())))()(((())()))))))((()(())())))(()())(((((()(()))(()((()))(()())()))))(()(()))()(()))(())(((())(()()))))()()))(((()))))(()()()()))())))((()()()(())()))()))))()()))()))))))((((((()()()))))())((()()(((()))))(()(())(()()())())())))()(((()()))(())((())))(()))(()()()())((())())())(()))))()))()((()(())()(()()(())(()))(())()))(())(()))))(())(())())(()()(()((()()((())))((()))()((())))(((()()()()((((()))(()()))()()()(((())((())())(()()(()()()))()((())(())()))())(((()()(())))()((()()())()())(()(())())(((())(())())((())(())()(((()()))(())))((())(()())())(())((()()()((((((())))((()(((((())()))()))(())(()()))()))(())()()))(())((()()())()()(()))())()((())))()((()()())((((()())((())())())((()((()))()))((())((()()(()((()()(((())(()()))))((()((())()(((())(()((())())((())(()((((((())())()(()())()(())(((())((((((()(())(()((()()()((()()(()()()())))()()(((((()()))()((((((()))()(()(()(()(((()())((()))())()((()))(())))()))()()))())()()))())((((())(()(()))(((((((())(((()(((((()(((()()((((())(((())())))(()()()(()(()))()))((((((()))((()(((()(())((()((((()((((((())(((((())))(((()(()))))(((()(((())()((())(()((()))(((()()(((())((((()(()(((((()))(((()(((((((()(()()()(()(()(()()())(())(((((()(())())()())(()(()(()))()(()()()())(()()(()((()))()((())())()(()))((())(()))()(()))()(((()(()(()((((((()()()()())()(((((()()(((()()()((()(((((()))((((((((()()()(((((()))))))(()()()(())(()))(()()))))(())()))(((((()(((((()()(()(()())(((()))((((()((()(()(()((()(()((())))()(((()((()))((()))(((((((((()((()((()(())))()((((()((()()))((())(((()(((((()()(()(()()((()(()()()(((((((())())()())))))((((()()(()))()))(()((())()(()(((((((((()()(((()(()())(()((()())((())())((((()(((()(((()((((()((()((((()(()((((((())((((((((((((()()(()()((((((((((((((()((()()))()((((((((((((())((((()(()())((()(()(()))()(((((()()(((()()))()())(())((()(((((()((())(((((()((()(((((()))()()((((())()((((())(((((((((()(())(()(())))())(()((())(((())(())(())())(()(()(())()()((()((())()(((()(((((()(())))()(((()((())))((()()()(((()(((()((()(()(())(()((()())(()(()(((()(((((((((())(()((((()()))(()((((()()()()(((()((((((((()(()()((((((()(()()(()((()((((((((((()()(((((((()())(())))(((()()))(((((()((()()())(()()((((())((()((((()))))(())((()(()()(((()(()(((()((((()(((((()))())())(()((())()))(((()())((())((())((((()((()((((((())(()((((()()))((((((())()(()))((()(((())((((((((((()()(((((()(((((()((()()()((((())))(()))()((()(())()()((()((((((((((()((())(())(((((()(()(()()))((((()((((()()((()(((()(((((((((()(()((()((()))((((((()(((())()()((()(((((((()())))()()(()((()((()()(((()(()()()()((((()((())((((()(((((((((()(((()()(((()(()(((()(((()((())()(()((()(()(()(()))()(((()))(()((((()((())((((())((((((())(()))(()((((())((()(()((((((((()()((((((()(()(()()()(())((()((()()(((()(((((((()()((()(((((((()))(((((()(((()(()()()(()(((()((()()((())(()(((((((((()(()((()((((((()()((())()))(((((()((())()())()(((((((((((()))((((()()()()())(()()(()(()()))()))(()))(()(((()()))())(()(()))()()((())(()())()())()(()))()))(()()(()((((((())((()(((((((((((()(())()((()(()((()((()(()((()((((((((((()()())((())()(())))((())()())()(((((()(()())((((()((()(())(()))(((())()((()))(((((())(()))()()(()))(((())((((()((((()(())))(((((((()))))())()())(())((())()(()()((()(()))()(()()(()()((()())((())((()()))((((()))()()))(()()(())()()(((((()(())((()((((()))()))(()())())(((()()(()()))(())))))(()))((())(((((()((((()))()((((()))()((())(((())))(((()())))((()(()()((";
//     // let path = "()())";

//     let total: i32 = path.chars().map(|c| {
//         match c {
//             '(' => 1,
//             ')' => -1,
//             _ => panic!("unknown character! {c}")
//         }
//     }).sum();

//     println!("{total}");

//     let mut pos: i32 = 0;
//     for (i, c) in path.char_indices() {
//         pos += match c {
//             '(' => 1,
//             ')' => -1,
//             _ => panic!("unknown character! {c}")
//         };

//         if pos < 0 {
//             println!("First index to go to basement is {}", i + 1);
//             break;
//         }
//     }
// }
