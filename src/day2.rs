use std::fs;

pub fn run() {
    let contents = fs::read_to_string("test_files/day2/input.txt").unwrap();

    let (part_1_result, part_2_result) = part_1_2_v2(&contents);

    println!("[Day 2]: part 1: {part_1_result}, part 2: {part_2_result}");
}

fn _part_1_2(data: &str) -> (u32, u32) {
    let mut sum = 0;
    let mut power: u32 = 0;

    for line in data.lines() {
        // line: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green

        let info: Vec<&str> = line.split(':').collect();
        // info: ["Game 1", "3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green"]

        let num: Vec<&str> = info[0].split(' ').collect();

        let num: u32 = num[1].parse().unwrap();

        let mut r = true;
        let mut g = true;
        let mut b = true;

        let mut r_count: u32 = 0;
        let mut g_count: u32 = 0;
        let mut b_count: u32 = 0;

        // println!("line [{line}], num {num}");

        for sub_game in info[1].split(";") {
            // sub_game: "3 blue, 4 red"
            for colors in sub_game.split(",") {
                // colors: "3 blue"
                let pieces: Vec<&str> = colors.trim().split(" ").collect();

                // println!("colors {colors}");

                let count: u32 = pieces[0].parse().unwrap();
                let color: &str = pieces[1];

                match color {
                    "red" => {
                        if count > 12 {
                            r = false;
                        }

                        r_count = r_count.max(count);
                    }
                    "green" => {
                        if count > 13 {
                            g = false;
                        }

                        g_count = g_count.max(count);
                    }
                    "blue" => {
                        if count > 14 {
                            b = false;
                        }

                        b_count = b_count.max(count);
                    }
                    _ => panic!("unknown color"),
                }
            }
        }

        if r && g && b {
            sum += num;
        }

        power += r_count * g_count * b_count;
    }

    // println!("power {power}");

    (sum, power)
}

fn part_1_2_v2(data: &str) -> (u32, u32) {
    let mut sum = 0;
    let mut power: u32 = 0;

    for line in data.lines() {
        // line: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green

        let info: Vec<&str> = line.split(':').collect();
        // info: ["Game 1", "3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green"]

        let num: Vec<&str> = info[0].split(' ').collect();

        let num: u32 = num[1].parse().unwrap();

        let mut valid = true;

        let mut r_count: u32 = 0;
        let mut g_count: u32 = 0;
        let mut b_count: u32 = 0;

        // println!("line [{line}], num {num}");

        for sub_game in info[1].split(";") {
            // sub_game: "3 blue, 4 red"
            for colors in sub_game.split(",") {
                // colors: "3 blue"
                let pieces: Vec<&str> = colors.trim().split(" ").collect();

                // println!("colors {colors}");

                let count: u32 = pieces[0].parse().unwrap();
                let color: &str = pieces[1];

                match color {
                    "red" => {
                        valid = valid && count <= 12;
                        r_count = r_count.max(count);
                    }
                    "green" => {
                        valid = valid && count <= 13;
                        g_count = g_count.max(count);
                    }
                    "blue" => {
                        valid = valid && count <= 14;
                        b_count = b_count.max(count);
                    }
                    _ => panic!("unknown color"),
                }
            }
        }

        if valid {
            sum += num;
        }

        power += r_count * g_count * b_count;
    }

    // println!("power {power}");

    (sum, power)
}

// Was bored and tried to do another year.
// fn run_day1_2015() {
//     let path = "((((()(()(((((((()))(((()((((()())(())()(((()((((((()((()(()(((()(()((())))()((()()())))))))))()((((((())((()))(((((()(((((((((()()))((()(())()((())((()(()))((()))()))()(((((()(((()()))()())((()((((())()())()((((())()(()(()(((()(())(()(())(((((((())()()(((())(()(()(()(())))(()((((())((()))(((()(()()(((((()()(()(((()(((((())()))()((()(()))()((()((((())((((())(()(((())()()(()()()()()(())((((())((())(()()))()((((())))((((()())()((((())((()())((())(())(((((()((((()(((()((((())(()(((()()))()))((((((()((())()())))(((()(()))(()()(()(((()(()))((()()()())((()()()(((())())()())())())((()))(()(()))(((((()(()(())((()(())(())()((((()())()))((((())(())((())())((((()(((())(())((()()((((()((((((()(())()()(()(()()((((()))(())()())()))(())))(())))())()()(())(()))()((()(()(())()()))(()())))))(()))(()()))(())(((((()(()(()()((())()())))))((())())((())(()(())((()))(())(((()((((((((()()()(()))()()(((()))()((()()(())(())())()(()(())))(((((()(())(())(()))))())()))(()))()(()(((((((()((((())))())())())())()((((((((((((((()()((((((()()()())())()())())())(())(())))())((()())((()(()))))))()))))))))))))))))())((())((())()()))))))(((()((()(()()))((())(()()))()()())))(())))))))(()(((())))())()())))()()(())()))()(()))())((()()))))(()))))()))(()()(())))))))()(((()))))()(()))(())())))))()))((()))((()))())(())))))))))((((())()))()))()))())(())()()(())))())))(()())()))((()()(())))(())((((((()(())((()(((()(()()(())))()))))))()))()(()((()))()(()))(()(((())((((())())(())(()))))))))())))))))())())))))())))))()()(((())()(()))))))))())))))(())()()()))()))()))(()(())()()())())))))))())()(()(()))))()()()))))())(()))))()()))))()())))))(((())()()))(()))))))))))()()))))()()()))))(()())())()()())()(()))))()(()))(())))))))(((((())(())())()()))()()))(())))))()(()))))(())(()()))()())()))()))()))()))))())()()))())())))(()))(()))))))())()(((())()))))))))()))()())))())))())))()))))))))))()()))(()()))))))(())()(()))))())(()))))(()))))(()())))))())())()()))))())()))))))))(()))))()))))))()(()())))))))()))())))())))())))())))))))())(()()))))))(()())())))()())()))))))))))))))())))()(())))()))())()()(())(()()))(())))())()())(()(()(()))))())))))))))))())(()))()))()))))(())()())()())))))))))))()()))))))))))))())())))))(()())))))))))))())(())))()))))))))())())(()))()))(())))()))()()(())()))))))()((((())()))())())))))()))()))))((()())()))))())))(())))))))))))))))))()))))()()())()))()()))))())()))((()())))())))(()))(()())))))))()))()))))(())))))))(())))))())()()(()))())()))()()))))())()()))))())()))())))))))(()))))()())()))))))))(()))())))(()))()))))(())()))())())(())())())))))))((((())))))()))()))()())()(())))()))()))()())(()())()()(()())()))))())())))))(()))()))))())(()()(())))))(())()()((())())))))(())(())))))))())))))))))()(())))))))()())())())()(()))))))))(()))))))))())()()))()(()))))))()))))))())))))))(())))()()(())()())))))(((())))()((())()))())))(()()))())(())())))()(((()())))))()(()()())))()()(()()(()()))())()(()()()))())()()))()())(()))))())))))())))(())()()))))(()))))(())(()))(())))))()()))()))))())()))()()(())())))((()))())()))))))()()))))((()(()))))()()))))))())))))())(()((()())))))))))))()())())))()))(()))))))(()))(())()())))(()))))))))())()()()()))))(()())))))))((())))()))(()))(())(())()())()))))))))(())))())))(()))()()))(()()))(()))())))()(())))())((()((()(())))((())))()))))((((())())()())))(())))()))))))())(()()((())))())()(()())))))(()())()))())))))))((())())))))))(()(()))())()()(()()(((()(((()())))))()))))))()(())(()()((()()(())()()))())()())()))()())())())))))))(((())))))))()()))))))(((())()))(()()))(()()))))(()(()()((((())()())((()()))))(()(())))))()((()()()())()()((()((()()))(()))(((()()()))(((())))()(((())()))))))((()(())())))(()())(((((()(()))(()((()))(()())()))))(()(()))()(()))(())(((())(()()))))()()))(((()))))(()()()()))())))((()()()(())()))()))))()()))()))))))((((((()()()))))())((()()(((()))))(()(())(()()())())())))()(((()()))(())((())))(()))(()()()())((())())())(()))))()))()((()(())()(()()(())(()))(())()))(())(()))))(())(())())(()()(()((()()((())))((()))()((())))(((()()()()((((()))(()()))()()()(((())((())())(()()(()()()))()((())(())()))())(((()()(())))()((()()())()())(()(())())(((())(())())((())(())()(((()()))(())))((())(()())())(())((()()()((((((())))((()(((((())()))()))(())(()()))()))(())()()))(())((()()())()()(()))())()((())))()((()()())((((()())((())())())((()((()))()))((())((()()(()((()()(((())(()()))))((()((())()(((())(()((())())((())(()((((((())())()(()())()(())(((())((((((()(())(()((()()()((()()(()()()())))()()(((((()()))()((((((()))()(()(()(()(((()())((()))())()((()))(())))()))()()))())()()))())((((())(()(()))(((((((())(((()(((((()(((()()((((())(((())())))(()()()(()(()))()))((((((()))((()(((()(())((()((((()((((((())(((((())))(((()(()))))(((()(((())()((())(()((()))(((()()(((())((((()(()(((((()))(((()(((((((()(()()()(()(()(()()())(())(((((()(())())()())(()(()(()))()(()()()())(()()(()((()))()((())())()(()))((())(()))()(()))()(((()(()(()((((((()()()()())()(((((()()(((()()()((()(((((()))((((((((()()()(((((()))))))(()()()(())(()))(()()))))(())()))(((((()(((((()()(()(()())(((()))((((()((()(()(()((()(()((())))()(((()((()))((()))(((((((((()((()((()(())))()((((()((()()))((())(((()(((((()()(()(()()((()(()()()(((((((())())()())))))((((()()(()))()))(()((())()(()(((((((((()()(((()(()())(()((()())((())())((((()(((()(((()((((()((()((((()(()((((((())((((((((((((()()(()()((((((((((((((()((()()))()((((((((((((())((((()(()())((()(()(()))()(((((()()(((()()))()())(())((()(((((()((())(((((()((()(((((()))()()((((())()((((())(((((((((()(())(()(())))())(()((())(((())(())(())())(()(()(())()()((()((())()(((()(((((()(())))()(((()((())))((()()()(((()(((()((()(()(())(()((()())(()(()(((()(((((((((())(()((((()()))(()((((()()()()(((()((((((((()(()()((((((()(()()(()((()((((((((((()()(((((((()())(())))(((()()))(((((()((()()())(()()((((())((()((((()))))(())((()(()()(((()(()(((()((((()(((((()))())())(()((())()))(((()())((())((())((((()((()((((((())(()((((()()))((((((())()(()))((()(((())((((((((((()()(((((()(((((()((()()()((((())))(()))()((()(())()()((()((((((((((()((())(())(((((()(()(()()))((((()((((()()((()(((()(((((((((()(()((()((()))((((((()(((())()()((()(((((((()())))()()(()((()((()()(((()(()()()()((((()((())((((()(((((((((()(((()()(((()(()(((()(((()((())()(()((()(()(()(()))()(((()))(()((((()((())((((())((((((())(()))(()((((())((()(()((((((((()()((((((()(()(()()()(())((()((()()(((()(((((((()()((()(((((((()))(((((()(((()(()()()(()(((()((()()((())(()(((((((((()(()((()((((((()()((())()))(((((()((())()())()(((((((((((()))((((()()()()())(()()(()(()()))()))(()))(()(((()()))())(()(()))()()((())(()())()())()(()))()))(()()(()((((((())((()(((((((((((()(())()((()(()((()((()(()((()((((((((((()()())((())()(())))((())()())()(((((()(()())((((()((()(())(()))(((())()((()))(((((())(()))()()(()))(((())((((()((((()(())))(((((((()))))())()())(())((())()(()()((()(()))()(()()(()()((()())((())((()()))((((()))()()))(()()(())()()(((((()(())((()((((()))()))(()())())(((()()(()()))(())))))(()))((())(((((()((((()))()((((()))()((())(((())))(((()())))((()(()()((";
//     // let path = "()())";

//     let total: i32 = path.chars().map(|c| {
//         match c {
//             '(' => 1,
//             ')' => -1,
//             _ => panic!("unknown character! {c}")
//         }
//     }).sum();

//     println!("{total}");

//     let mut pos: i32 = 0;
//     for (i, c) in path.char_indices() {
//         pos += match c {
//             '(' => 1,
//             ')' => -1,
//             _ => panic!("unknown character! {c}")
//         };

//         if pos < 0 {
//             println!("First index to go to basement is {}", i + 1);
//             break;
//         }
//     }
// }
